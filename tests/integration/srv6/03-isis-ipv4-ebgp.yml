---
message: |
  The tested device (DUT) is a PE (ASBR) running SRv6 with IS-IS, using both iBGP and inter-AS eBGP to 2 peers to form
  an IPv6-only network to interconnect two IPv4-only networks. The validation test checks end-to-end IPv4 connectivity
  across the resulting multi-AS SRv6 path.
  See https://www.ietf.org/archive/id/draft-mishra-idr-v4-islands-v6-core-4pe-06.html

  See IETF draft https://www.ietf.org/id/draft-mishra-spring-inter-domain-routing-arch-01.html Figure 1

                                           SRv6 Next SID Topology


                Loc:fc00:0:1::/48             Loc:fc00:0:2::/48       Loc:fc00:0:3::/48
                Lo0:fc00:0:1::1               Lo0:fc00:0:2::1         Lo0:fc00:0:3::1
                 +-------+                     +-------+                    +-------+
                 |   AS1 |2001:1::2/127        |   AS1 |       2001:1::5/127|  AS2  |
           H1 -- |   PE1 |---------------------|   PE2 |--------------------|  PE3  | -- H2
                 |       |        2001:1::3/127| (ASBR)|2001:1::4/127       |(ASBR) |
                 +-------+                     +-------+                    +-------+
                                                 *DUT*
                           iBGP (Remote Peer)             eBGP (Local Peer)

  Operational considerations:
  * always use Next-Hop-Unchanged (NHU) on all eBGP boundaries on both sides of the eBGP peering to signal
    "End to End SID" for SID propagation End-to-End in both directions
  * don't use Next-Hop-Self on iBGP PE-RR peering so that the received service SID from an Ingress Domain is propagated
   "End to End" to an Egress Domain and vice versa in both directions

addressing:
  p2p:
    ipv4: False               # ipv6-only
    ipv6: 2001:1::/48         # SRv6 requires ipv6 addresses on interfaces

  loopback:
    ipv4: False               # No need for ipv4 loopbacks, this avoids creating ipv4 ibgp sessions too
    # ipv6: 2001::/48           # SRv6 requires ipv6 loopback addresses
    ipv6: fc00:0::/48         # SRv6 requires ipv6 loopback addresses, here make them overlap with locator range

  srv6_locator:
    ipv6: fc00::/40
    prefix6: 48

srv6.bgp: False
srv6.vpn:
  ipv4: [ ibgp, ebgp ]        # Enable IPv4 VPN in the overlay for both ibgp and ebgp neighbors

# Use regular IPv6 BGP for eBGP
bgp.sessions:
  ipv6: [ ibgp, ebgp ]
bgp.activate:
  ipv6: [ ebgp ]

bgp.advertise_loopback: True  # Not using IS-IS for this here

groups:
  _auto_create: True
  hosts:
    members: [ h1, h2 ]
    device: linux
    provider: clab
  pe:
    members: [ dut, pe1, pe3 ]
    module: [ bgp ]
    bgp.import: [ connected ]
  x_switches:
    members: [ pe1, pe3 ]
    device: frr
    provider: clab

nodes:
  pe1:
    module: [ isis, bgp, srv6, vrf ]
    bgp.as: 65001
  dut:
    module: [ isis, bgp, srv6 ] # No vrf
    bgp.as: 65001
    bgp.import: [ connected ]  # Could add isis here
    bgp.next_hop_self: False   # Preserve SID E2E
  pe3:
    bgp.as: 65002              # Tests inter-AS SIDs
    module: [ bgp, srv6, vrf ] # No IS-IS
    srv6.igp: []

vrfs:
  customer:

links:
- h1:
  pe1:
    vrf: customer
  isis: False                 # Using BGP to announce these prefixes
- pe1:
  dut:
- dut:
  pe3:
  # role: internal              # Could enable IS-IS on this link
- pe3:
    vrf: customer
  h2:

validate:
  isis:
    description: Check ISIS sessions with DUT (wait up to 30 seconds)
    wait: 30
    wait_msg: Waiting for ISIS adjacency
    nodes: [ pe1 ]
    plugin: isis_neighbor('dut',level='L2',area='49.0001')
    stop_on_error: true
  ebgp:
    description: Check EBGP session with activation of IPv4 over IPv6
    wait: 10
    wait_msg: Waiting for EBGP sessions to start
    nodes: [ pe3 ]
    plugin: bgp_neighbor(node.bgp.neighbors,'dut',af='ipv6',activate='vpnv4')
    stop_on_error: true
  ibgp:
    description: Check IBGP session with activation of IPv4 over IPv6
    wait: 10
    wait_msg: Waiting for IBGP sessions to start
    nodes: [ pe1 ]
    plugin: bgp_neighbor(node.bgp.neighbors,'dut',af='ipv6',activate='vpnv4')
    stop_on_error: true
  ping:
    description: Ping-based end-to-end reachability test
    nodes: [ h1 ]
    plugin: ping('h2')
