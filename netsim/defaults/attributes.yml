# Core _netlab_ attributes: global, link, interface, node, VLAN, VRF...
# 
global:
  addressing:
  defaults:
  groups:
  links:
  module:
  name: str
  nodes:
  plugin: list
  provider: str
internal: [ input,includes,pools,Provider,Plugin,message ]
can_be_false: [ link,interface ]
link:
  bandwidth: int
  bridge: str
  name: str
  prefix:                                           # Prefix is too complex to validate here -- links module will do the job
  role: str
  pool: str
  type: { type: str, valid_values: [ lan, p2p, stub, loopback, vlan_member ] }
  unnumbered: bool
  interfaces:
  mtu: { type: int, min_value: 64, max_value: 65535 }
  vlan_name: str
link_internal: [ linkindex,parentindex ]
link_no_propagate: [ prefix,interfaces,gateway ]
link_module_no_propagate: [ vlan ]                  # Do not propagate VLAN attributes to node interfaces -- see #575
interface:
  node: str
  ipv4: { type: ipv4, use: interface }
  ipv6: { type: ipv6, use: interface }
  ifindex: int
node:
  name: str
  interfaces: list
  module: list
  device: str
  box: str
  id: { type: int, min_value: 1, max_value: 150 }
  config: list
  group: list
  role: str
  mtu: { type: int, min_value: 64, max_value: 65535 }
  provider: str
  cpu:
  memory: int
  unmanaged: bool
vlan:
  id: { type: int, min_value: 1, max_value: 4095 }
  vni: { type: int, min_value: 1, max_value: 16777215 }
  mode: { type: str, valid_values: [ bridge, irb, route ] }
  prefix:
vrf:
  rd: rd
  import: list
  export: list
  id: { type: int, min_value: 1 }
  loopback:                                         # Loopback is a mix of multiple formats, let the VRF module handle it
pool:
  ipv4: { type: ipv4, use: prefix }
  ipv6: { type: ipv6, use: prefix }
  start: { type: int, min_value: 1 }
  prefix: { type: int, min_value: 1, max_value: 32 }
  allocation: { type: str, valid_values: [ p2p, sequential, id_based ] }
  mac: mac
  unnumbered: bool
pool_no_copy: [ start, prefix, mac ]
prefix:
  ipv4: { type: ipv4, use: prefix }
  ipv6: { type: ipv6, use: prefix }
  allocation: { type: str, valid_values: [ p2p, sequential, id_based ] }
group:
  members: list
  vars: dict
  config: list
  node_data: dict
  device: str
  module: list
