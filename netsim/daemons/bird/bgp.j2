{% if 'router_id' in bgp %}
router id {{ bgp.router_id }};
{% endif %}

# Define filtered tables
ipv4 table filtered_ipv4;
ipv6 table filtered_ipv6;

filter bgp_prefixes {
  if source ~ [ RTS_STATIC, RTS_BGP ]
    then accept "Static or BGP route:", net;

{% if bgp.advertise_loopback|default(False) %}
  if source ~ [ RTS_DEVICE ] && ifname = "lo"
    then accept "advertise loopback:", net;
{% endif %}
{% for intf in interfaces if 'bgp' in intf and intf.bgp.advertise|default(False) %}
  if source ~ [ RTS_DEVICE ] && ifname = "{{ intf.ifname }}"
    then accept "bgp.advertise:", net;
{% endfor %}
  reject "not accepted:", net, " source=", source, " preference=", preference;
}

{% for af in ['ipv4','ipv6'] %}
protocol aggregator agg_{{ af }} {
  table master{{ af[3:] }};
  export filter bgp_prefixes;
  aggregate on net;
  merge by {
    bool has_ospf = false;
    bool has_bgp = false;
    for route r in routes do {
      if r.source = RTS_OSPF then has_ospf = true;
      if r.source = RTS_BGP then has_bgp = true;
      print net," src=",r.source," pref=",r.preference;

      if r.preference > preference then preference = r.preference;
    }
    if (has_ospf && has_bgp) then {
      preference = 160;
    }
    accept "Aggregated:",net," pref=",preference;
  };
  import all;
  peer table filtered_{{ af }};
}
{% endfor %}

{% for pfx in bgp.originate|default([]) %}
{%   if loop.first %}
protocol static bgp_ipv4 {
  ipv4;
{%   endif %}
  route {{ pfx }} unreachable;
{%   if loop.last %}
}
{%   endif %}
{% endfor %}

{#
 Build a BGP export filter per neighbor type, to filter communities
#}
{% for ntype in [ 'ebgp', 'ibgp', 'localas_ibgp' ] %}
filter bgp_export_{{ ntype }} {
{%   set list = bgp.community[ntype]|default([]) %}
{%   if 'standard' not in list %}
  bgp_community.empty;
{%   endif %}
{%   if 'large' not in list %}
  bgp_large_community.empty;
{%   endif %}
{%   if 'extended' not in list %}
  bgp_ext_community.empty;
{%   endif %}

  accept;
}
{% endfor %}

{% for n in bgp.neighbors %}
{%   for af in [ 'ipv4','ipv6' ] if af in n %}
protocol bgp bgp_{{ n.name }}_{{ af }} {
{%     set loopback = loopback|default({}) %}
{%     set local_ip = loopback[af]|default('') %}
  local {{ local_ip.split('/')[0] if n.type == 'ibgp' else '' }} as {{ n.local_as|default(bgp.as) }};
  neighbor {{ n[af] }} as {{ n['as'] }};
{%     if n.password is defined %}
  password "{{ n.password }}";
{%     endif %}
{%     if n.rs|default(False) %}
  rs client;
{%     endif %}
{%     if n.rs_client|default(False) %}
  enforce first as off;
{%     endif %}
{%     if bgp.rr|default(False) and ((not n.rr|default('') and n.type == 'ibgp') or n.type == 'localas_ibgp') %}
  rr client;
{%       if bgp.rr_cluster_id|default(False) %}
  rr cluster id {{ bgp.rr_cluster_id }};
{%       endif %}
{%     endif %}
{%     if af in n.activate and n.activate[af] %}
  {{ af }} {
    import all;
    export filter bgp_export_{{ n.type }};
    table filtered_{{ af }};

{%       if 'next_hop_self' in bgp and bgp.next_hop_self and 'ibgp' in n.type %}
    next hop self {{ 'on' if n.type == 'localas_ibgp' else 'ebgp' }};
{%       endif %}
  };
{%     endif %}
}
{%   endfor %}
{% endfor %}
