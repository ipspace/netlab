---
- local_action:
    module: tempfile
    state: file
    suffix: temp
    prefix: ansible.sros.{{ inventory_hostname }}.
  register: tempfile_1

- name: Set default provisioning model to use OpenConfig (sros_use_openconfig={{sros_use_openconfig}})
  when: sros_use_openconfig|default(true)
  set_fact:
    sros_provisioning_model: "sros.openconfig"

# - name: Example how to check if a BGP RR is being used
#   vars:
#     rr: "{{ groups['all']|map('extract',hostvars)|map(attribute='bgp.rr')|list }}"
#   set_fact:
#     uses_route_reflector: "{{ rr != [] }}"

- name: Check if OpenConfig can be used as provisioning method/model (config_template={{config_template}})
  when: "'ospf' in config_template or 'sr' in module or not sros_use_openconfig|default(true)"
  set_fact:
    sros_provisioning_model: "sros.gnmi"

- name: Select provisioning template
  set_fact:
    template_to_use: "{{ config_template|replace('sros.j2',sros_provisioning_model+'.j2') }}"

- local_action:
    module: template
    src: "{{ template_to_use }}"
    dest: "{{ tempfile_1.path }}"

- name: Check that prepared config from {{template_to_use}} in {{tempfile_1.path}} is valid YAML
  vars:
    cfg: "{{ lookup('file', tempfile_1.path ) }}"
  debug: msg="{{ cfg | from_yaml }}"

- name: Wait up to 120s for gNMI(TCP {{ansible_port}}) to be ready on {{ ansible_host }}
  # vars:
  #  ansible_connect_timeout: 60 # Increase from default 30
  wait_for:
    port: "{{ ansible_port }}"
    host: "{{ ansible_host }}"
    connect_timeout: 60
    timeout: 120
    sleep: 10 # Wait 10s between attempts

- block:
  - name: Enable Open Config YAML modules (retry to give Containerlab a chance to finish configuration)
    when: enable_open_config is not defined
    tags: [ initial ]
    nokia.grpc.gnmi_config:
      prefix: configure
      update:
      - path: system/management-interface/yang-modules/openconfig-modules
        val: True # {{ sros_provisioning_model == "sros.openconfig" }}
    register: enable_open_config
    retries: 4
    delay: 15
    until: enable_open_config is success

  rescue:
  - name: reset the gNMI connection, then try one more time
    meta: reset_connection

- debug: var=enable_open_config
# - debug: var=hostvars

- name: Update node configuration (using gNMI SET based on YAML template {{template_to_use}})
  when: d!=[] or u!=[] or r!=[]
  vars:
    cfg: "{{ lookup('file', tempfile_1.path ) | from_yaml }}"
    d: "{{ cfg.delete | default([]) }}"
    u: "{{ cfg.updates | default([]) }}"
    r: "{{ cfg.replace | default([]) }}"
  nokia.grpc.gnmi_config:
    # prefix: configure
    delete: "{{ d }}"
    replace: "{{ r }}"
    update: "{{ u }}"
  register: gnmi_set_result
  retries: 2
  until: gnmi_set_result is success

- debug: var=gnmi_set_result

# Alternative: ansible.netcommon.cli_command
# Uses network_cli connection
# - community.network.sros_command:
# - nokia.sros.md:
#   commands: "{{ lookup('file', tempfile_1.path ).splitlines() }}"

# Let's use Netconf + OpenConfig
# - name: use lookup filter to provide xml configuration
  #netconf_config:
  #  xml: "{{ lookup('file', tempfile_1.path) }}"
  #  host: "{{ ansible_host }}"
  #  username: "{{ ansible_user }}"
  #  password: "{{ ansible_ssh_pass }}"
#  community.yang.configure:

# - name: Fetch given yang model and its dependencies from remote host
#   community.yang.fetch:
#     # name: Nokia
#     dir: "{{playbook_dir}}/{{inventory_hostname}}/yang_files"
#   register: result
#
# - name: configure interface using structured data in JSON format
#   community.yang.configure:
#    config: "{{ lookup('file', tempfile_1.path) | to_json }}"
#    file: "{{ playbook_dir }}/{{inventory_hostname}}/yang_files/Nokia-ifmgr-cfg.yang"
#    search_path: "{{ playbook_dir }}/{{inventory_hostname}}/yang_files"
#   register: result

- local_action:
    module: file
    path: "{{ tempfile_1.path }}"
    state: absent
  when: tempfile_1.path is defined
