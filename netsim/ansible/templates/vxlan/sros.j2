{% from "templates/evpn/sros.macro.j2" import mpls_l3vnis with context %}

{% macro vxlan_service(vrf,type,vni,evi,rd,rts,is_routed=False) %}
- path: configure/service/vpls[service-name={{ vrf }}]
  val:
{# May get created for first time here, when not referenced from any interfaces #}
   customer: '1'
   admin-state: enable
   service-id: {{ evi }} # transit EVI for l3, should not overlap
   vxlan:
    instance:
    - vxlan-instance: 1
      vni: {{ vni }}
   bgp:
   - bgp-instance: 1
     # route-distinguisher: {{ rd }} # Don't configure this, use auto RD
{% if type=='l2' %}
     route-target:
      export: "target:{{ rts.export[0] }}"
      import: "target:{{ rts.import[0] }}"
{% endif %}
   bgp-evpn:
    evi: {{ evi }}
{% if type=='l3' %}
    routes:
     ip-prefix:
      advertise: True # Symmetric IRB using RT5 prefixes
     mac-ip:
      advertise: False
{% endif %}
    vxlan:
    - vxlan-instance: 1
      bgp-instance: 1
      admin-state: enable
      ecmp: 8
{% if is_routed %}
   routed-vpls:
    vxlan-ipv4-tep-ecmp: True # Enable ECMP for routed VXLAN
{% endif %}
{% endmacro %}

updates:
{% if vlans is defined and vxlan.vlans is defined %}
{%  for vname in vxlan.vlans if vlans[vname].vni is defined %}
{%   set vlan = vlans[vname] %}
{%   if vlan.evpn is defined %}
{%    set is_routed = vlan.mode|default('irb') != 'bridge' %}
{{ vxlan_service('vlan'+vlan.id|string,'l2',vlan.vni,vlan.evpn.evi,vlan.evpn.rd,vlan.evpn,is_routed) }}
{%   else %}
     # TODO non-EVPN VXLAN case
{%   endif %}
{%  endfor %}
{% endif %}

{# Symmetric IRB interfaces, note using VRF ID as transit EVI value #}
{{ mpls_l3vnis( vxlan_service, 'transit_vni' ) }}
