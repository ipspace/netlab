{% macro bgp_policy(vrf,is_import,communities) %}
{% set name = vrf + "_" + ('import' if is_import else 'export') %}
- path: routing-policy/community-set[name={{name}}]
  val:
   member:
{% for c in communities %}
   - "target:{{c}}"
{% endfor -%}

- path: routing-policy/policy[name={{name}}]
  val:
   statement:
   - sequence-id: 10
{%   if is_import %}
     match:
      bgp:
       community-set: "{{ name }}"
{%   endif %}
     action:
{%    if is_import %}
      accept: { }
{%    else %}
      accept:
       bgp:
        communities:
         add: "{{ name }}"
{%    endif %}
{% endmacro %}

{% macro bgp_config(vrf,_as,router_id,vrf_bgp,vrf_context) %}

{% if 'import' in vrf_context %}
{% set import_policy = vrf + "_import" %}
{{ bgp_policy(vrf,1,vrf_context.import) }}
{% else %}
{% set import_policy = "accept_all" %}
{% endif -%}

{% if 'export' in vrf_context %}
{% set export_policy = vrf + "_export" %}
{{ bgp_policy(vrf,0,vrf_context.export) }}
{% else %}
{% set export_policy = "accept_all" %}
{% endif -%}

- path: network-instance[name={{vrf}}]/protocols/bgp
  val:
   autonomous-system: {{ _as }}
   router-id: {{ router_id }}
   ebgp-default-policy:
    export-reject-all: False
    import-reject-all: False

{#
    Configure BGP Groups
#}
   group:
{% for g in ['ibgp-ipv4','ibgp-ipv6','ebgp','ebgp-unnumbered'] %}
{% set _type = g[:4] %}
   - group-name: {{ g }}
     admin-state: enable
     import-policy: {{ import_policy if 'ebgp' in g else 'accept_all' }}
     export-policy: {{ export_policy if 'ebgp' in g else 'accept_all' }}
     timers:
      connect-retry: 10
      _annotate_connect-retry: "Reduce default 120s to 10s"
      minimum-advertisement-interval: 1

{# BGP communities #}
{%   if bgp.community[ _type ]|default([]) %}
{%   set list = bgp.community[ _type ] %}
     send-community:
      standard: {{ 'standard' in list or 'both' in list }}
      large: {{ 'large' in list }}
{%   endif %}

{# iBGP #}
{%   if g in ['ibgp-ipv4','ibgp-ipv6'] %}
     peer-as: {{ _as }}
     ipv4-unicast:
      admin-state: {{ 'enable' if g == 'ibgp-ipv4' and 'ipv4' in bgp.address_families['ibgp'] else 'disable' }}
     ipv6-unicast:
      admin-state: {{ 'enable' if g == 'ibgp-ipv6' or 'ipv6' in bgp.address_families['ibgp'] else 'disable' }}
     evpn:
      admin-state: {{ 'enable' if evpn is defined and 'ibgp' in evpn.session|default([]) else 'disable' }}
{%   if g[5:] in loopback %}
     transport:
      local-address: {{ loopback[ g[5:] ]|default('')|ipaddr('address') }}
{%   endif %}
{%   if vrf_bgp.rr|default(0) %}
     route-reflector:
      cluster-id: {{ vrf_bgp.rr_cluster_id|default(False) or router_id }}
      client: True
{%   endif %}
{%   else %}

{# eBGP #}
     next-hop-self: {{ 'True' if bgp.next_hop_self|default(False) else 'False' }}
{%   if g == 'ebgp-unnumbered' %}
     local-as:
     - as-number: {{ bgp.underlay_as|default(_as) }}
       prepend-global-as: false
     ipv4-unicast:
      advertise-ipv6-next-hops: true
      receive-ipv6-next-hops: true
{%   else %}
     ipv4-unicast:
{%   endif %}
      admin-state: {{ 'enable' if 'ipv4' in bgp.address_families['ebgp'] else 'disable' }}
     ipv6-unicast:
      admin-state: {{ 'enable' if 'ipv6' in bgp.address_families['ebgp'] else 'disable' }}
{%   endif %}

{% endfor %}

{# Configure BGP address families #}
{% for af in ['ipv4','ipv6'] if vrf_bgp[af]|default(0) %}
   {{ af }}-unicast:
    admin-state: enable
    multipath:
     max-paths-level-1: 64
     max-paths-level-2: 64 # indirect nexthops
{%   if loopback[af] is defined and bgp.advertise_loopback %}
{# {{     bgp_network(af,loopback[af]) }} #}
{%   endif %}

{% for l in vrf_bgp.interfaces|default([]) if l.bgp.advertise|default("") and l[af] is defined and not 'vrf' in l %}
{# {{     bgp_network(af,l[af]) }} #}
{%   endfor %}
{%   for pfx in bgp.originate|default([]) if af == 'ipv4' %}
{# {{     bgp_network(af,pfx) }} #}
{%   endfor %}

{% endfor %}

{#
  Define IPv4 and IPv6 BGP neighbors
#}
{% for n in vrf_bgp.neighbors %}
{% for af in ['ipv4','ipv6'] if n[af] is defined %}
{% if n[af] is string %}
- path: network-instance[name={{vrf}}]/protocols/bgp/neighbor[peer-address={{n[af]}}]
  val:
   description: {{ n.name }}
   peer-group: {{ 'ebgp' if n.type=='ebgp' else ('ibgp-'+af) }}
{% if n.type != 'ibgp' %}
   peer-as: {{ n.as }}
{% endif %}
{% if n.local_as is defined %}
   local-as:
   - as-number: {{ n.local_as }}
{%   if n.type == 'ebgp' %}
     prepend-global-as: False # Don't include iBGP AS in eBGP advertisements
{%   endif %}
{% endif %}
{% elif n[af]==True and af=='ipv6' %}
{# BGP unnumbered for IPv6 LLA #}

- path: network-instance[name={{vrf}}]/ip-forwarding
  val:
   receive-ipv4-check: false
   _annotate_receive-ipv4-check: "Allow IPv4 on IPv6 unnumbered interfaces"

{% set ns = namespace(l=false) %}
{% for i in vrf_bgp.interfaces|default([]) if i.ifindex == n.ifindex %}
{% set ns.l = i %}
{% endfor %}
{% if ns.l %}
{% set if_name_index = ns.l.ifname.split('.') %}
{% set if_name = if_name_index[0] %}
{% set if_index = if_name_index[1] if if_name_index|length > 1 else '0' %}
- path: network-instance[name={{vrf}}]/protocols/bgp/dynamic-neighbors/interface[interface-name={{if_name}}.{{if_index}}]
  val:
   peer-group: "ebgp-unnumbered"
   allowed-peer-as: [ {{ n.as }}..{{ n.as }} ]
{% endif %}
{% endif %}
{% endfor %}
{% endfor %}

{#
  Add extra IPv4 prefixes using static blackhole routes, add to export
#}
- path: network-instance[name={{vrf}}]/next-hop-groups/group[name=blackhole]
  val:
   blackhole:
     generate-icmp: True

{% for pfx in vrf_bgp.originate|default([]) %}
- path: network-instance[name={{vrf}}]/static-routes/route[prefix={{pfx}}]
  val:
   next-hop-group: blackhole
- path: routing-policy/prefix-set[name=external_routes]
  val:
   prefix:
   - ip-prefix: {{ pfx }}
     mask-length-range: exact
{% endfor %}

{% if 'sr' in module|default([]) %}
{# Configure BGP shortcuts via SR-ISIS #}
- path: network-instance[name={{vrf}}]/protocols/bgp/ipv4-unicast/next-hop-resolution
  val:
   ipv4-next-hops:
    tunnel-resolution:
     mode: prefer
     _annotate_mode: "tunnel-table lookup over FIB"
     allowed-tunnel-types: [ sr-isis ]
{% endif %}
{% endmacro %}
