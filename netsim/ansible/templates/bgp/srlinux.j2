{% macro communities(ip,list) -%}
  neighbor {{ ip }} send-community standard {{ 'true' if 'standard' in list or 'both' in list else 'false' }}
  neighbor {{ ip }} send-community large {{ 'true' if 'large' in list else 'false' }}
{%- endmacro %}
{#
   Global BGP neighbor definition
#}
{% macro neighbor_global(n,ip) %}
  neighbor {{ ip }}
   description {{ n.name }}
   peer-group {{ n.type }}
{% if n.type != 'ibgp' %}
   peer-as {{ n.as }}
{% endif %}
  exit
{%- endmacro %}
{#
   Address family BGP neighbor definition
#}
{% macro neighbor_af(n,ip,local_loopback) %}
{% if n.type == 'ibgp' %}
  neighbor {{ ip }} transport local-address {{ local_loopback }}
{%   if bgp.community.ibgp|default([]) %}
{{ communities(ip,bgp.community.ibgp) }}
{%   endif %}
{% else %}{# EBGP IPv4 neighbor #}
{%   if bgp.community.ebgp|default([]) %}
{{ communities(ip,bgp.community.ebgp) }}
{%   endif %}
{% endif %}
{%- endmacro %}
{#
   BGP network statement
#}
{% macro bgp_network(af,pfx) %}
{%   if af == 'ipv4' %}
  network {{ pfx|ipaddr('network') }} mask {{ pfx|ipaddr('netmask') }}
{%   else %}
  network {{ pfx|ipaddr('0') }}
{%   endif %}
{%- endmacro %}

/network-instance default protocols bgp
autonomous-system {{ bgp.as }}
router-id {{ loopback['ipv4']|ipaddr('address') }}
ipv4-unicast admin-state disable
ebgp-default-policy export-reject-all false
ebgp-default-policy import-reject-all false
{#
    Configure IPv4 and IPv6 BGP neighbors
#}
group ibgp admin-state enable peer-as {{ bgp.as }} next-hop-self {{ bgp.next_hop_self|default(false)|lower }}
group ibgp timers connect-retry 1 minimum-advertisement-interval 1
group ebgp admin-state enable next-hop-self {{ bgp.next_hop_self|default(false)|lower }}
group ebgp timers connect-retry 1 minimum-advertisement-interval 1

{#
    Configure iBGP Route Reflection
#}
{% if bgp.rr|default(0)|bool %}
group ibgp {
 route-reflector {
  cluster-id {{ loopback['ipv4']|ipaddr('address') }}
  client true
 }
 next-hop-self false
}
{% endif %}


{% for n in bgp.neighbors %}
{%   for af in ['ipv4','ipv6'] if n[af] is defined %}
{{     neighbor_global(n,n[af]) }}
{%   endfor %}
{% endfor %}

{# Configure BGP address families #}
{% for af in ['ipv4','ipv6'] if bgp[af] is defined %}
 # address-family {{ af }}
 {{ af }}-unicast admin-state enable multipath max-paths-level-1 64 max-paths-level-2 64

{%   if loopback[af] is defined and bgp.advertise_loopback %}
{# {{     bgp_network(af,loopback[af]) }} #}
{%   endif %}

{%   for l in links|default([]) if l.bgp.advertise|default("") and l[af] is defined %}
{# {{     bgp_network(af,l[af]) }} #}
{%   endfor %}
{%   for pfx in bgp.originate|default([]) if af == 'ipv4' %}
{# {{     bgp_network(af,pfx) }} #}
{%   endfor %}

{%   for n in bgp.neighbors if n[af] is defined %}
{{     neighbor_af(n,n[af],loopback[af]|default('')|ipaddr('address')) }}
{%   endfor %}
{% endfor %}

{#
  Define default import/export policies for iBGP and eBGP: accept all
#}
/routing-policy policy accept-all default-action accept
/network-instance default protocols bgp group ebgp import-policy accept-all export-policy accept-all
/network-instance default protocols bgp group ibgp import-policy accept-all export-policy accept-all

{#
  Add extra IPv4 prefixes using static blackhole routes, add to export
#}
/network-instance default next-hop-groups group blackhole blackhole set generate-icmp true
{% for pfx in bgp.originate|default([]) %}
/network-instance default static-routes route {{ pfx }} next-hop-group blackhole
/routing-policy prefix-set external_routes prefix {{ pfx }} mask-length-range exact
{% endfor %}
