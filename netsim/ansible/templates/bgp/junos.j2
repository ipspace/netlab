routing-options {
  autonomous-system {{ bgp.as }};
{% if bgp.router_id|ipv4 %}
  router-id {{ bgp.router_id }}
{% endif %}
{% if bgp.originate is defined %}
  static {
{% for pfx in bgp.originate|default([]) %}
    route {{ pfx|ipaddr('0') }} discard;
{% endfor %}
  }
{% endif %}
}

{# initialize default policies #}

{# internal community to handle policy flows #}
{# 
#  single "default" policy should never have "then accept", except for last one.
#  policies are evaluated, and in case of "accept" we must add the internal mark community and jump to the next policy.
#  only the last policy, if matching the internal mark community, should remove the community and accept the route.
#  in this way we can concatenate multiple policies, and have all of them evaluated in order of priority:
#   - next-hop-self (if needed)
#   - advertise + announce + default originate when needed (based on a route-filter-list)
#   - redistribute (remember to always redistribute bgp, since we are overriding the default behavior)
#   - (custom policies - which may force accept/reject)
#   - default final policy
#}
policy-options community x-route-permit-mark members large:65535:0:65536;

policy-options {
  delete: policy-statement bgp-advertise;
  delete: policy-statement bgp-redistribute;
  delete: route-filter-list bgp-announce;
}

policy-options {

  route-filter-list bgp-announce {
{%   for pfx in bgp.originate|default([]) %}
    {{ pfx|ipaddr('0') }} exact;
{%   endfor %}
  }

  policy-statement next-hop-self {
    term next-hop-self {
      from {
        route-type external;
      }
      then {
        next-hop self;
      }
    }
  }

  policy-statement bgp-advertise {
    term advertise {
      from {
        protocol direct;
        interface [ 
          {% if bgp.advertise_loopback %} lo0.0 {% endif %}
          {%- for l in interfaces if l.bgp.advertise|default("") and not 'vrf' in l %}
          {{ l.ifname }}
          {% endfor %} ];
      }
      then {
        community add x-route-permit-mark;
        next policy;
      }
    }

    term originate {
      from {
        protocol static;
        route-filter-list bgp-announce;
      }
      then {
        community add x-route-permit-mark;
        next policy;
      }
    }

  }

  policy-statement bgp-redistribute {
    term redis_bgp {
      from protocol bgp;
      then {
        community add x-route-permit-mark;
        next policy;
      }
    }
  }

  policy-statement bgp-final {
    term final-option {
      from community x-route-permit-mark;
      then {
        community delete x-route-permit-mark;
        accept;
      }
    }
    term default-reject {
      then reject;
    }
  }

}

protocols {
  delete: bgp;
}
protocols {
  bgp {
{% for af in ['ipv4','ipv6'] if bgp[af] is defined and loopback[af] is defined %}
    group ibgp-peers-{{ af }} {
      type internal;
      export [ 
{%   if bgp.next_hop_self|default(false) %}
          next-hop-self
{%   endif %}
          bgp-advertise
          bgp-redistribute
          bgp-final
        ];
      advertise-inactive;
{% if bgp.rr|default(False) %}
      cluster {{ bgp.rr_cluster_id|default(False) or bgp.router_id }};
{% endif %}
{%   for n in bgp.neighbors if n[af] is defined and n.type == 'ibgp' %}
      neighbor {{ n[af] }} {
{%     if n._source_intf[af] is defined %}
        local-address {{ n._source_intf[af]|ipaddr('address') }};
{%     endif %}
        description {{ n.name }};
{%     if n.activate[af]|default(false) %}
        family {{ 'inet' if af == 'ipv4' else 'inet6' }} {
          unicast;
        }
{%     else %}
        shutdown;
{%     endif %}
      }
{%   endfor %}
    }
{% endfor %}
    group ebgp-peers {
      export [ 
          bgp-advertise
          bgp-redistribute
          bgp-final
        ];
      advertise-inactive;
{# treat localas_ibgp as ebgp session --> no usage of local address #}
{% for n in bgp.neighbors if (n.type == 'ebgp' or n.type == 'localas_ibgp') %}
{%   for af in ['ipv4','ipv6'] if n[af] is defined %}
      neighbor {{ n[af] }} {
        peer-as {{ n.as }};
        description {{ n.name }};
{%     if n.local_as is defined %}
        local-as {{ n.local_as }}{% if n.replace_global_as|default(True) %} no-prepend-global-as{% endif +%};
{%     endif %}
{%     if n.activate[af]|default(false) %}
        family {{ 'inet' if af == 'ipv4' else 'inet6' }} {
          unicast;
        }
{%     else %}
        shutdown;
{%     endif %}
      }
{%   endfor %}
{% endfor %}
    }
  }
}
